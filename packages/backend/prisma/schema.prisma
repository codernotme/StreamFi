datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id              String         @id @default(uuid())
  email           String?        @unique
  password        String?
  name            String?
  displayName     String?
  about           String?
  payoutEmail     String?
  googleId        String?        @unique
  role            UserRole       @default(AUDIENCE)
  credits         Float          @default(0)
  banned          Boolean        @default(false)
  bannedAt        DateTime?
  banReason       String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  streams         Stream[]
  transactions    Transaction[]
  notifications   Notification[]
  walletAddress   String?        @unique
  vaultId         BigInt?        @unique
  chatMessages    ChatMessage[]
  mutes           Mute?
}

model Stream {
  id                String       @id @default(uuid())
  title             String
  ingestUrl         String?
  streamKey         String?      @unique
  status            StreamStatus @default(IDLE)
  streamer          User         @relation(fields: [streamerId], references: [id])
  streamerId        String
  monetizationRules Json?
  createdAt         DateTime     @default(now())
  startedAt         DateTime?
  endedAt           DateTime?
  transactions      Transaction[]
  chatMessages      ChatMessage[]
}

model Transaction {
  id        String            @id @default(uuid())
  amount    Float
  currency  String            @default("USD")
  type      TransactionType
  status    TransactionStatus
  provider  String?
  user      User              @relation(fields: [userId], references: [id])
  userId    String
  stream    Stream?           @relation(fields: [streamId], references: [id])
  streamId  String?
  metadata  Json?
  createdAt DateTime          @default(now())
}

model Notification {
  id        String   @id @default(uuid())
  type      String
  title     String
  body      String
  read      Boolean  @default(false)
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  createdAt DateTime @default(now())
}

model ChatMessage {
  id        String   @id @default(uuid())
  stream    Stream   @relation(fields: [streamId], references: [id])
  streamId  String
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  text      String
  createdAt DateTime @default(now())
}

model Mute {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @unique
  reason    String?
  createdAt DateTime @default(now())
}

// Indexed on-chain NFTs for faster ownership queries
model NftToken {
  tokenId      BigInt   @id
  ownerAddress String   @db.VarChar(66)
  tokenURI     String?
  updatedAt    DateTime @updatedAt
}

// Track last processed block for the NFT indexer
model NftSyncState {
  id        String  @id @default("nitrolite")
  lastBlock BigInt  @default(0)
  updatedAt DateTime @updatedAt
}

enum UserRole {
  STREAMER
  AUDIENCE
  ADMIN
}

enum StreamStatus {
  IDLE
  LIVE
  ERROR
}

enum TransactionType {
  DONATION
  NFT_SALE
  PAYOUT
  CREDIT_PURCHASE
  REFUND
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}