datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id              String         @id @default(auto()) @map("_id") @db.ObjectId
  email           String?        @unique
  password        String?
  name            String?
  displayName     String?
  about           String?
  payoutEmail     String?
  googleId        String?        @unique
  role            UserRole       @default(AUDIENCE)
  credits         Float          @default(0)
  banned          Boolean        @default(false)
  bannedAt        DateTime?
  banReason       String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  streams         Stream[]
  transactions    Transaction[]
  notifications   Notification[]
  walletAddress   String?        @unique
  vaultId         BigInt?        @unique
  chatMessages    ChatMessage[]
  mutes           Mute?
  payouts         PayoutRequest[]
}

model Stream {
  id                String       @id @default(auto()) @map("_id") @db.ObjectId
  title             String
  ingestUrl         String?
  streamKey         String?      @unique
  status            StreamStatus @default(IDLE)
  streamer          User         @relation(fields: [streamerId], references: [id])
  streamerId        String       @db.ObjectId
  monetizationRules Json?
  createdAt         DateTime     @default(now())
  startedAt         DateTime?
  endedAt           DateTime?
  transactions      Transaction[]
  chatMessages      ChatMessage[]
}

model Transaction {
  id        String            @id @default(auto()) @map("_id") @db.ObjectId
  amount    Float
  currency  String            @default("USD")
  type      TransactionType
  status    TransactionStatus
  provider  String?
  user      User              @relation(fields: [userId], references: [id])
  userId    String            @db.ObjectId
  stream    Stream?           @relation(fields: [streamId], references: [id])
  streamId  String?           @db.ObjectId
  metadata  Json?
  createdAt DateTime          @default(now())
}

model PayoutRequest {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  streamer   User     @relation(fields: [streamerId], references: [id])
  streamerId String   @db.ObjectId
  amount     Float
  currency   String   @default("USD")
  status     PayoutStatus @default(PENDING)
  note       String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Notification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  type      String
  title     String
  body      String
  read      Boolean  @default(false)
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @db.ObjectId
  createdAt DateTime @default(now())
}

model ChatMessage {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  stream    Stream   @relation(fields: [streamId], references: [id])
  streamId  String   @db.ObjectId
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?  @db.ObjectId
  text      String
  createdAt DateTime @default(now())
}

model Mute {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @unique @db.ObjectId
  reason    String?
  createdAt DateTime @default(now())
}

// Indexed on-chain NFTs for faster ownership queries
model NftToken {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  tokenId      BigInt   @unique
  ownerAddress String
  tokenURI     String?
  updatedAt    DateTime @updatedAt
}

// Track last processed block for the NFT indexer
model NftSyncState {
  id        String  @id @map("_id")
  lastBlock BigInt  @default(0)
  updatedAt DateTime @updatedAt
}

enum UserRole {
  STREAMER
  AUDIENCE
  ADMIN
}

enum StreamStatus {
  IDLE
  LIVE
  ERROR
}

enum TransactionType {
  DONATION
  NFT_SALE
  PAYOUT
  CREDIT_PURCHASE
  REFUND
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

enum PayoutStatus {
  PENDING
  APPROVED
  PAID
  REJECTED
}